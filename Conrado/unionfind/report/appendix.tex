\appendix
\section{Union Operation: Code}
From \texttt{main.cc} there is a single call to the Union operation. Such call is executed by the following merge function:

\begin{center}
    \begin{verbatim}
void UnionFind::merge(unsigned int i, unsigned int j) {
    unsigned int ri = find(i);
    unsigned int rj = find(j);
    if (ri == rj) return;
    --numBlocks;
    switch(strat) {
        case UnionStrategy::QU:
            mergeQU(ri, rj);
            break;
        case UnionStrategy::UW:
            mergeUW(ri, rj);
            break;
        case UnionStrategy::UR:
            mergeUR(ri, rj);
            break;
        default:
            break;
    }
}
    \end{verbatim}
\end{center}

Firstly one can see that there are two calls to the \texttt{find} operation which, depending on the strategy choosen for the path compression they will behave differently. For now let us just consider how the union operation is implemented 

\subsection{Quick-Union}
Anyone who chooses to use this strategy as their union strategy will perform the union operation in an extremely efficient time—more precisely, in $\Theta(1)$—at the cost of increased time complexity in the find operation. The following code provides an implementation of this approach:

\begin{center}
    \begin{verbatim}
void UnionFind::mergeQU(unsigned int ri, unsigned int rj) {
    P[ri] = rj;
}
    \end{verbatim}
\end{center}

\subsection{Union by Weight}
An straightforward heuristic in order to choose how we can merge two different trees is to just merge the smaller one into the larger one. We will expect to not increase as much the path that we will create as if we do it the other way around. The following code provides an implementation of this approach:

\begin{verbatim}
void UnionFind::mergeUW(unsigned int ri, unsigned int rj) {
    //Recall that representatives here are negative numbers
    if (P[ri] >= P[rj]) {
        P[rj] += P[ri];
        P[ri] = rj;
    }

    else {
        P[ri] += P[rj];
        P[rj] = ri;
    }
}
\end{verbatim}

\subsection{Union by Rank}
A similar idea from the Union by Weight heuristic can be applied here, but this time, we aim to control the rank of a tree, which we will use as an upper bound for its height. The following code provides an implementation of this approach:

\begin{verbatim}
void UnionFind::mergeUR(unsigned int ri, unsigned int rj) {

    //Recall that representatives here are negative numbers
    if (P[ri] >= P[rj]) {
        P[rj] = min(P[rj], P[ri] - 1);
        P[ri] = rj;
    }

    else {
        P[ri] = min(P[ri], P[rj] - 1);
        P[rj] = ri;
    }
}
\end{verbatim}
